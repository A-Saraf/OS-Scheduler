OS-SCHEDULER - TECHNICAL DOCUMENTATION
=====================================================

PROJECT OVERVIEW
----------------
Project Name: OS-Scheduler
Type: Interactive Web Application
Purpose: CPU Scheduling visualization and performance analysis tool
Framework: React 18 + TypeScript
Build Tool: Vite

TECHNOLOGY STACK
----------------

Frontend Framework:
- React 18.3.1 - Modern UI framework with hooks
- TypeScript 5.8.3 - Type-safe development
- Vite 5.4.19 - Fast development server and build tool

Styling & UI:
- Tailwind CSS 3.4.17 - Utility-first CSS framework
- Radix UI - Accessible component library
- Lucide React 0.462.0 - Icon library
- PostCSS - CSS processing and optimization
- Autoprefixer - Cross-browser compatibility

Data Visualization:
- Recharts 2.15.4 - Chart library for React
  - Bar charts for algorithm comparison
  - Performance metrics visualization
  - Custom tooltips and legends

Form Management:
- React Hook Form 7.61.1 - Form state management
- Zod 3.25.76 - Schema validation
- @hookform/resolvers 3.10.0 - Form validation integration

State Management & Routing:
- React Query 5.83.0 - Server state management
- React Router DOM 6.30.1 - Client-side routing

User Experience:
- Sonner 1.7.4 - Toast notifications
- Framer Motion - Animations and transitions
- Tailwind Animate - CSS animations

Development Tools:
- ESLint 9.32.0 - Code linting and formatting
- React Hook Form 7.61.1 - Form management
- Zod 3.25.76 - Schema validation
- Sonner 1.7.4 - Toast notifications
- React Router DOM 6.30.1 - Client-side routing

PROJECT STRUCTURE
-----------------

src/
├── components/
│   ├── ui/                    # Reusable UI components (20+ files)
│   │   ├── dialog.tsx
│   │   ├── button.tsx
│   │   ├── select.tsx
│   │   └── ...
│   ├── CPUScheduler.tsx       # Main application component
│   ├── ComparisonModal.tsx    # Algorithm comparison with complexity analysis
│   ├── ComplexityInfoModal.tsx # Detailed complexity explanations
│   ├── GanttChart.tsx        # Timeline visualization
│   ├── QueueAnimation.tsx     # Real-time queue visualization
│   ├── MetricsPanel.tsx       # Performance metrics display
│   ├── ProcessList.tsx        # Process management interface
│   ├── FileUpload.tsx         # CSV import functionality
│   └── ExecutionTable.tsx     # Detailed execution results
├── hooks/
│   ├── useSoundEffects.ts     # Audio feedback management
│   └── use-toast.ts           # Toast notification hook
├── types/
│   └── scheduler.ts           # TypeScript interfaces and types
├── utils/
│   ├── schedulerAlgorithms.ts # Core algorithm implementations
│   └── fileParser.ts         # CSV parsing utilities
├── lib/
│   └── utils.ts               # Utility functions
└── main.tsx                   # Application entry point

CORE CPU SCHEDULING ALGORITHM IMPLEMENTATION
----------------------------------------------

CPU Scheduling Algorithms:
1. FCFS (First Come First Served) - O(n) time complexity
2. SJF (Shortest Job First) - O(n log n) average, O(n²) worst
3. SRTF (Shortest Remaining Time First) - O(n log n) average, O(n²) worst
4. Priority Scheduling - O(n log n) average, O(n²) worst
5. Round Robin - O(n × q) where q is time quantum

Data Structures Used:
- FIFO Queue - FCFS algorithm implementation
- Min-Heap (Priority Queue) - SRTF and Priority scheduling
- Circular Queue - Round Robin algorithm
- Arrays - Process storage and sorting operations

Process Management:
- Process creation and validation
- Arrival time and burst time management
- Priority levels for priority scheduling
- Time quantum configuration for Round Robin

Algorithm Implementations:
- FCFS: O(n) time complexity, FIFO queue
- SJF: O(n log n) average, O(n²) worst, array sorting
- SRTF: O(n log n) average, O(n²) worst, min-heap priority queue
- Priority: O(n log n) average, O(n²) worst, min-heap priority queue
- Round Robin: O(n × q) where q is time quantum, circular queue

DESIGN SYSTEM
------------

Color Palette:
- Primary: Purple gradient (#8b5cf6, #a855f7)
- Secondary: Blue (#5b9cff, #3b82f6)
- Accent: Cyan (#06b6d4, #0891b2)
- Success: Green (#22c55e, #16a34a)
- Warning: Yellow/Orange (#eab308, #f97316)
- Error: Red (#ef4444, #dc2626)

Typography:
- Font Family: Inter (Google Fonts)
- Weights: 400 (Regular), 500 (Medium), 600 (Semibold), 700 (Bold), 800 (Extra Bold)
- Sizes: Responsive scaling from xs (12px) to 3xl (30px)

UI Components:
- Glass Cards: Frosted glass effect with backdrop blur
- Buttons: Gradient backgrounds with hover states
- Forms: Floating labels and validation states
- Charts: Custom styled with consistent color scheme

DATA FLOW ARCHITECTURE
----------------------

State Management:
const [processes, setProcesses] = useState<Process[]>([]);
const [timeline, setTimeline] = useState<TimelineItem[]>([]);
const [metrics, setMetrics] = useState<Metrics | null>(null);
const [algorithm, setAlgorithm] = useState<AlgorithmType>('FCFS');

Data Processing Pipeline:
1. Input → Process creation (manual or CSV)
2. Validation → Form validation and type checking
3. Algorithm Selection → Choose scheduling algorithm
4. Execution → Run algorithm with process data
5. Visualization → Generate timeline and metrics
6. Analysis → Complexity comparison and detailed breakdown

Component Communication:
- Props drilling for data flow
- Callback functions for state updates
- Custom hooks for shared logic
- Context not used (simple state management)

BUILD & DEPLOYMENT
------------------

Development Commands:
npm run dev          # Start development server (localhost:8080)
npm run build        # Build for production
npm run preview      # Preview production build
npm run lint         # Run ESLint

Build Configuration:
- Vite Config: TypeScript support, React plugin
- Output: Single-page application with optimized assets
- Bundle Size: ~500KB (gzipped)
- Browser Support: Modern browsers

DEPENDENCIES
------------

Production Dependencies:
- React ecosystem (React, TypeScript, Tailwind)
- UI libraries (Radix UI, Lucide, Recharts)
- Utilities (React Hook Form, Zod, Sonner)

Development Dependencies:
- Vite (build tool)
- ESLint (linting)
- PostCSS (CSS processing)
- TypeScript compiler

KEY FEATURES
------------

- CPU Scheduling Visualization: Real-time algorithm execution with animations
- Interactive Gantt Charts: Timeline visualization of process execution
- Queue Animation: Watch processes move through scheduling queues
- Performance Analysis: Waiting time, turnaround time, response time metrics
- Algorithm Comparison: Side-by-side performance comparison
- CSV Import: Bulk process data upload functionality
- Sound Effects: Audio feedback for process events
- Modern UI: Glassmorphism design with smooth animations
- Responsive Design: Works seamlessly on desktop and mobile
- Educational Info Modals: Detailed algorithm explanations
- Preset Scenarios: Pre-configured test cases
- Keyboard Shortcuts: Ctrl+Enter to run, Esc to reset

PERFORMANCE METRICS
------------------

- Bundle size: ~500KB (gzipped)
- First Contentful Paint: <1s
- Time to Interactive: <2s
- Lighthouse Score: 95+ (Performance, Accessibility, Best Practices)

BROWSER SUPPORT
---------------

- Chrome 90+
- Firefox 88+
- Safari 14+
- Edge 90+

ALGORITHM COMPLEXITY REFERENCE
------------------------------

Time Complexity Levels (from best to worst):
O(1) - Constant time
O(log n) - Logarithmic time
O(n) - Linear time
O(n log n) - Linearithmic time
O(n²) - Quadratic time
O(n³) - Cubic time
O(2^n) - Exponential time
O(n!) - Factorial time

Space Complexity:
All algorithms use O(n) space for process storage and timeline data.

EDUCATIONAL VALUE
-----------------

Operating System Concepts Demonstrated:
- CPU Scheduling Algorithms: FCFS, SJF, SRTF, Priority, Round Robin
- Queue Operations: Enqueue, dequeue, circular queue behavior
- Process States: New, Ready, Running, Waiting, Terminated
- Context Switching: Process switching overhead
- Performance Metrics: Waiting time, turnaround time, response time
- Time Quantum: Time slice management in Round Robin
- Priority Levels: Process priority management
- Gantt Charts: Timeline representation of process execution

Target Audience:
- Computer Science students (OS courses)
- Operating Systems learners
- Algorithm enthusiasts
- Educators and teachers
- System performance analysts

Learning Outcomes:
- Understanding CPU scheduling algorithms
- Visualizing process queue management
- Comparing algorithm efficiency
- Analyzing performance trade-offs
- Applying theoretical OS concepts to practical scenarios

=====================================================
Generated: February 2026
Project Repository: OS-Scheduler
Purpose: CPU Scheduling Visualization and Performance Analysis Tool